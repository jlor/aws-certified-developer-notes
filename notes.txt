- S3
    - Details
        - Max 100 buckets
        - Unique bucket names, DNS name convention
        - Multiple regions. Data stays in region unless explicitly moved.
        - Min size: 0b
        - Max size: 5Tb
        - > 5Gb requires multipart upload
        - Multipart upload recommended on >= 100Mb
        - Multipart can upload parallel and out of order
        - CompleteMultipartUpload API reassembles the file after multipart upload
        - Can be encrypted before WRITE to disk, decrypted ON download
    - Data Consistency
        - New objects: Read-after-write consistency
            - No stale reads possible
            - Potential higher read latency
            - Potential lower read throughput
        - Updated objects: Eventual consistency
            - Stale reads possible
            - Lowest read latency
            - Highest read throughput
    - Performance
        - Consistent:
            - > 100 put/list/update requests/s
            - > 300 get requests/s
        - Burst:
            - > 300 put/list/update requests/s
            - > 800 get requests/s
        - Request more if needed prior to production
    - Performance Optimizations
            - S3 keeps index of object keynames in each region
            - BAD:
                - ex/2016-12-07/p1.jpg
                - ex/2016-12-07/p2.jpg
                - ex/2016-12-07/p3.jpg
                - ex/2016-12-07/p4.jpg
            - GOOD:
                - ex/e87f-2016-12-07/p1.jpg
                - ex/a023-2016-12-07/p2.jpg
                - ex/b753-2016-12-07/p3.jpg
                - ex/18fa-2016-12-07/p4.jpg
            - Requests don't all float through same node (indexes built on hashes rather than the same date string)
            - GET heavy workflow => use CloudFront CDN as caching service
                - Limits the requests on S3
    - Hosting static websites
        - HTML/CSS/Javascript in Buckets.
            - Custom error pages
            - Custom index file
            - Custom redirect rules
        - S3 gives default URL
            - <bucket-name>.s3-website-<AWS region>.amazonaws.com
            - Route 53 integration for custom names
        - Bucket name must match domain name (dashsoft.dk -> S3://dashsoft.dk, www.dashsoft.dk -> s3://www.dashsoft.dk)
            - if someone used that bucket name, feature can't be used
    - S3 IAM and Bucket policies
        - more: https://aws.amazon.com/blogs/security/iam-policies-and-bucket-policies-and-acls-oh-my-controlling-access-to-s3-resources/
        - IAM policy: User level (User policy)
            - Multiple users can be assigned same IAM policy
            - Attached to a user, so can not be used to grant anonymous users permissions
            - JSON based 
        - Bucket policy: Resource level (resource-based policy)
            - JSON file attached to resource
                - Who is allowed to access resources?
                - What that user can do with those resources?
                - Can contain conditions (e.g. StringEquals)
            - max 20kb size
            - SHOULD BE USED to manage cross-account permissions for all Amazon S3 permissions
        - ACLs:
            - Legacy.
            - For buckets and objects
            - More restrictive than Bucket Policies
                - Can manage permissions on INDIVIDUAL OBJECTS WITHIN A BUCKET
            - XML based
            - Grant read/write to OTHER AWS ACCOUNTS
            - No conditional permissions
            - Can not explicitly deny permissions
            - Only way to manage access to objects not owned by the bucket owner
        - Bucket owner has full permission as default
            - Bucket owner paying bills can deny access or modify objects regardless of who owns them
        - Explicit DENY always overrides allows in policies.
    - Logging S3 API calls
        - CloudTrail
            - Bucket levels operations
            - Logs all API calls
            - Use with CloudWatch to filter certain calls and notify on occurences
        - Amazon S3 Server Access Logs
            - Object level operations
            - Logs GET
            - May take up to 1 hour before showing logs
            - on a best effort basis - not for completely accurate logging!!
        - Saved to S3 bucket
    - Object Versioning
        - Three states: Versioning enabled, Versioning suspended, unversioned
            - Once version-enabled a bucket cannot be unversioned.
            - Version-enabled can be version suspended
                - Existing versions will remain.
                - New objects will be given version ID null
        - Setup at bucket level
        - New versions of objects are given a Version ID
        - Upon GET the latest version is returned
        - Upon DELETE all versions remain in bucket, but a delete marker will be inserted on the object. Will appear to be deleted.
        - Permanent deletion of version: Specify ID. Next ID will be current version.
        - Restore a version:
            - Copy from ID (old versions ID) to same bucket
                - works because: GET -> PUT (gets new ID)
            - Delete current versions ID (i.e. next ID will be current)
        - Lifecycle management to handle versions life. Examples:
            - Send noncurrent versions to amazon Glacier?
            - Permanently delete objects that have been non-current for 180 days
    - S3 Encryption
        - Protecting data in-transit
            - SSL or client-side encryption or...
            - AWS KMS-managed (Key Management System) Customer Master Key (CMK)
                - Unique encryption key for each object
                - Amazon knows master key
                - On upload:
                    - Client request key from AWS KMS
                    - KMS returns key: plain text + cipher blob
                    - plain text used to encrypt object data
                    - cipher blob to upload to S3 as object metadata
                - On download:
                    - Client downloads encrypted object data + cipher blob in object metadata
                    - Client sends cipher blob to KMS and gets plain text back
                    - plain text used to decrypt object data
            - Client-side master key:
                - Amazon does NOT know master key
                - on upload:
                    - Client provides master key to AWS S3 encryption client (LOCALLY)
                    - S3 client generates random data key and encrypts it with master key
                    - S3 client encrypts data using data key and uploads material description as part of object metadata (x-amz-meta-x-amz-key)
                - on download:
                    - Client downloads encrypted object WITH metadata
                    - Metadata tells client which master key to use
                    - Client decrypts the data key using that master key
                    - Client uses decrypted data key to decrypt object
        - Protecting data at rest
            - Server side encryption (by AWS S3)
                - Must add x-amz-server-side-encryption request header to upload request
                - Uses AES-256 
                - Bucket policy can require all objects to use server-side encryption
                    - StringNotEquals "x-amz-server-side-encryption" = "AES-256"
            - KMS-managed encryption keys
                - Uses customer master keys
                - More flexibility in controlling keys
            - Customer-provided encryption keys
                - Gives the option to generate your own keys outside the environment
                - Amazon does NOT store the encryption key
        - Both can be used simultaneously
- DynamoDB
    - Components
        - Table: Collection of data (items). Think DB table.
        - Item: Collection of attributes. Think tuples.
        - Attribute: Fundamental data element. Think DB fields/columns.
        - Schemaless: Each item can have its own distinct attributes - other than primary key!
        - Scalar attributes: Most attributes are scalar meaning they can only have one value. (Strings, numbers & Binary)
        - Nested attributes: Nested attributes can support up to 32 levels nesting depth
        - Primary Key
            - Partition key: A single attribute that distinguish the item from all others. Also known as the "hash attribute".
            - Composite key (partition key + sort key): Partition key is fed to hash function to determine physical storage location. Multiple items with same partition key will be placed on same partition sorted according to the sort key! Sort key also known as the "range attribute".
            - Must be of scalar value: String, Number, Binary.
        - Secondary indexes: Allows quering using alternate key (in addition to queries on primary key)
            - Global (GSI): Index with partition key + sort key that can be different from those on the table (max 5 per table)
                - Consume THEIR OWN provision throughput for read/write (specified upon index creation)
                - Can be created AFTER table creation
                - Updated asynchronuously => changes are EVENTUALLY CONSISTENT
            - Local (LSI): Index that has same partition key as the table, but different sort key. (max 5 per table)
                - Consume SAME read/write throughput from original table
                    - Every partition is scoped to a table partition with the same partition key value
                - Can only be created DURING table creation
                - Can be queried using either eventual consistent or strongly consistent.
            - Index will belong to a table (the base table). 
            - Can hold 5 LSI and 5 GSI for a total of 10 indexes per table.
            - Indexes are maintained automatically by DynamoDB.
            - Upon Index creation you can specify which attributes should be "projected" or copied from base table to index. DynamoDB will as a minimum project key attributes (partition key + sort key)
                - KEYS_ONLY (default. Smallest index, more performant)
                - INCLUDE (custom attributes included)
                - ALL  (INCLUDE *.. Biggest index, least performance)
            - Querying an attribute not in primary key/secondary indexes is still possible, but will be queried on main table - NOT index. Will cost more latency+read capacity
        - Read/Write capacity
            - Used for partitioning across multiple servers
        - Streams
            - Optional
            - Captures data modification events represented by a "stream record" on:
                - New item added: Stream captures an image of the entire item.
                - Item updated: Stream captures before and after image of modified attributes.
                - Item deleted: Stream captures image of entire item before deletion.
            - Contains:
                - Name of table
                - Event timestamp
                - other metadata
            - A record lives for 24 hours and is then removed from the stream
            - Can be used as a trigger for AWS Lambda.
                - Example: New Customer entries trigger Lambda which in turn trigger Simple Email Service (SES) to send welcome mail to said customer.
    - Overview & limits
        - Fully managed NoSQL
        - Built in Monitoring
        - Consistent and performance
            - Data stored on SSDs
            - Can control throughput read/write capacity
            - Can spread load between servers/tables
            - Replication across multiple availability zones in an AWS region
        - Different levels of consistency
            - Eventually consistent
            - Strongly consistent
        - Conditional updates & concurrency control
            - Conditional writes
            - Atomic counter
        - Integration with Elastic MapReduce & RedShift
        - Streams
        - Provisioned Throughput
            - Flexible read/write performance capacity
                - Set during table creation
                - Can be changed at anytime without downtime or performance degradation
            - Ability to reserve capacity
        - Limits
            - 256 tables per region (increase upon request)
            - partition key length: 2048 byte max (2kb), 1 byte min
            - Sort key length: 1024 byte max (1kb), 1 byte min
            - Item size: 400kb including attribute name + value
            - API specific limits
                - Table updates (CreateTable, UpdateTable, DeleteTable): 10 simultaneous actions
                - BatchGetItem returns max 100 items
                    - Must be less than 16mb
                - BatchWriteItem can contain 25 PutItem or DeleteItem
                    - Must be less than 16mb
                - Query & Scan result set is limited to 1mb of data per call
                    - LastEvaluatedKey included in response to continue retrieval from last returned element
    - Provisioned Throughput
        - Unit of read capacity
            - For items up to 4kb:
                - 1 strongly consistent read per second
                - 2 eventually consistent read per second
        - Unit of write capacity
            - For items up to 1kb
                - 1 write per second
        - Calculating read capacity
            - Round up to nearest 4kb multiplier
                - Items that are 3kb in size still use 4kb data. Can do 1 strongly consistent read or 2 eventually consistent reads per second
            - Example:
                - item size 3kb
                - Want to read 80 items per second from the table
                - how many read capacity units required?
                    - Take 1 item, round UP to nearest 4kb multiplier. 
                    - Take that number divide by 4 => this is how many reads you need for ONE item
                    - Multiply with items to read per second. Divide by 1 for STRONG consistency, 2 for eventual consistency:
                        - 80 * (3kb [rounded to 4] / 4kb) / 1 read/s = 80 units of STRONGLY CONSISTENT read capacity
                        - 80 * (3kb [rounded to 4] / 4kb) / 2 read/s = 40 units of EVENTUALLY CONSISTENT read capacity
            - Local secondary indexes
                - Uses read/write capacity from parent table
                - If only reading index keys and projected attributes the calculations are equal to regular reads
                    - Calculate using the size of index entry, NOT table item size
                    - Rounded up to nearest 4kb
                    - Cost saving because => index entry size < table item size!
                - If querying non-projected attributes / non-keys we get extra latency and read capacity cost:
                    - Uses read capacity from index and EVERY item from the table - not just the attribute needed
                    - Attribute projection VERY important
            - Global secondary indexes
                - Have their own throughput capacity
                - Only support eventually consistent reads => 8kb/read capacity unit (4 kb * 2 reads/s)
                - Calculate using the size of index entry, NOT table item entry
                - Cost saving because => index entry size < table item size!
        - Calculating write capacity
            - Round up to nearest 1kb multiplier
            - Example:
                - item size 1.5kb
                - 10 writes per second
                - how many write capacity units required?
                    - Take 1 item, round UP to nearest 1kb multiplier
                    - Take that number, divide by 1 => this is how many writes you need for ONE item
                    - Multiply with items to read per second.
                        - 10 * (1.5kb [rounded to 2] / 1kb / 1 write/s) = 20 units of write capacity
            - Local secondary indexes
                - Uses read/write capacity from parent table
                - ADDing items, UPDATEing items and DELETEing items also uses table write capacity
                    - Adding item with projected attribute costs 1 write operation to put into index
                        - Add
                    - Updating item with previously undefined attribute that is projected to index: 1 write operation
                        - Add
                    - Updating item with previously DEFINED attribute that is projected to index: 2 writes
                        - Delete
                        - Add
                    - Delete item with attribute projected to index: 1 write
                        - Delete
            - Global secondary indexes
                - Have their own throughput capacity
                - Follow same capacity rules as local secondary indexes
        - Exceeding throughput
            - Requests exceeding throughput may be throttled
            - For global secondary indexes, ALL indexes must have enough write capacity or the WRITE may be throttled -- even if the write doesn't affect the index
                - This includes any local secondary indexes as well as keys
    - Query vs. Scan API calls
        - Query
            - Finds items using PRIMARY KEY values from table or secondary index
            - Defaults to return all matching items
            - Will only return result up to 1mb. Will include lastEvaluatedKey entry to continue retrieval from last returned element 
                - If LastEvaluatedKey == null => reached last matching item
            - Defaults to Eventually consistent, can be set to strongly consistent
                - Global secondary indexes (GSI) only support EVENTUALLY consistent
            - Can use conditional operators and filters to return precise results
            - Returns all attributes of an item, or only the ones you want
            - Data returned in sorted order by sort key value (ascending default)
        - Scan
            - Reads every item in a table
            - Can only return ResultSets up to 1mb in size
            - Benefits
                - Can apply filters to the results to refine values
                - Can return only specific attributes with the "ProjectionExpression" parameter
                - ResultSet includes LastEvaluatedKey entry to continue retrieval from last returned element
            - Negatives
                - Filters applied after data has been scanned
                    - The more filters the slower performance. 
                    - The larger the data the slower performance.
                - Returns only filtered results
                - Only eventual consistent reads available
            - Keep in mind
                - Can reduce Page Size with the "Limit" parameter, to limit how much data you try to retrieve at the same time
                    - Reduce chance of being throttled
                - Avoid performing scans on mission-critical tables
                    - Throughput allocated per table! => Scans may impact available read/writes for the application!!
                    - Possible to create tables with duplicated contents. Application can then rotate which table to pull data from and perform scans on "non-active" tables
                - If throttled (response code: You exceeded your provisioned throughput) try again with exponential backoff
                - Can program logic to increase throughput (using Update Table operation)
                    - Once requests die down a bit => back off on provision throughput
    - Conditional Writes & Atomic Counters
        - Atomic Counters
            - Increment/decrement value of an attribute without interfering with other write requests
            - Requests are applied in order they are received
            - Updates are NOT idempotent - it will update teh value each time it is called
            - use case: Increasing view count
        - Conditional Writes
            - Checks for a condition before proceeding with the operation
            - Supported for PutItem, DeleteItem, UpdateItem operations
            - Specify conditions in ConditionExpression
                - Can contain attribute names, conditional operators, and built-in functions
            - For this reason updates ARE idempotent!!
            - Failed conditional writes return ConditionalCheckFailedException
    - Connecting to DynamoDB from your app using Identity Providers
        - Can use temporary security credentials to make calls to AWS services
        - Example: 
            - Users on mobile app need ability to communicate with DynamoDB.
            - No hardcoded credentials in the app => would need to push new client in case of updated credentials
        - Options:
            - Web Identity Federation
                - Authentication token provided from:
                    - Web identity federation: Facebook, Google, etc. (OpenID Connect 2.0 -- OIDC) providers
                    - Enterprise identity federation: Authentication of users in organizations network
                - Authentication token exchanged for temporary credentials in AWS which in turn map to an IAM role with permission to use DynamoDB.
            - Amazon Cognito
                - Preferred way to manage identities
                    - Handles identity federation work for us
                - Cognito Identity
                    - Create unique identities for users
                    - Authenticate identities with identity providers - or our own auth process
                    - Supports unauthenticated identities (anonymous)
                    - Save mobile user data
                    - Use credentials obtained to sync data with Cognito Sync
                - Cognito Sync
                    - Sync user data across mobile devices and the web
                    - Client libraries cache data locally
            - IAM roles
                - We need roles for our users to assume
                - Role gives access to DynamoDB
                - Temporary credentials are associated with a specific IAM role.
- SNS
    - Concepts
        - Pub-sub service (publication/subscription)
        - Publishers: Sends messages to SNS topic
            - Must have correct permissions (IAM role, etc.)
        - Topic: Communication channels where we publish and subscribe
            - Topic name
                - Must be unique
                - Limit of 256 characters. Alphanumeric, hyphens and underscores allowed
                - Stored redundantly on multiple servers and data centers
            - Display name (used for SMS messages)
            - Has an identifier ARN
        - Messages: Messages published to specific topic ARN
        - Subscriptions: Subscriptions on specific topic ARN
            - Topic ARN
            - Protocol: The protocol to be used for communication with our endpoint
            - Endpoint: Endpoint to contact using the defined protocol when a message appears on the subscribed topic
            - Has a subscription ID
        - Applications: 
        - Endpoints: Endpoints subscribed to a topic
            - HTTP/HTTPS: Website to receive information upon message in topic
            - Email / Email-JSON
                - Email-JSON sends as JSON object. Email sends text-based email.
                - Requires confirmation of email address to avoid spam.
            - Amazon SQS
                - SNS uses push, SQS uses pull. I.e. we can push to SQS and pull when possible rather than be ready to accept all the time.
            - Application: e.g. mobile application
            - AWS Lambda
                - Supports versioning / aliases
        - Fanout scenario: Message sent to single topic, pushed to multiple endpoints
            - Allows for parallel asynchronous processing
    - Managing access
        - Integrates with IAM for control over our own user's permission
            - Control access for our own users
            - Can't grant access to other AWS accounts
            - Can include conditions
            - Can use both IAM policies adn Access Control policies simultaneously
            - IAM policies can grant temporary security credentials
        - Access control policies
            - AWS account has only permissions by default
            - Can grant access to other AWS accounts
            - Allows override of default deny (default deny = soft deny, any other policy will override)
            - Explicit denies override allows
            - Order of policies does NOT matter
            - based off of IAM
        - Can control:
            - Who is allowed to publish
            - Who is allowed to subscribe
            - Under what conditions
    - SNS Message Data
        - POSTs to HTTP/S endpoints include specific headers (x-amz-sns-*)
        - JSON formatted key-value pairs
            - Message: Message value specified when the notification was published to the topic
            - MessageID: UUID; Same ID must be used for retries.
            - Subject: Optional parameter
            - Timestamp: Time (GMT) when notification was published
            - TopicArn: ARN for the topic
            - Type: Type of message (i.e. Notifications are type Notification)
            - Signature: Base64-encoded SHA1withRSA signature of message+messageID+subject+type+timestamp+topicarn
            - SignatureVersion: Version of the Amazon SNS signature used
            - SigningCertURL: The URL to the certificate used to sign the message
            - UnsubscribeURL: URL to unsubscribe
            - up to 10 additional optional message attributes:
                - Useful for SQS and mobile push notifications (not sent to other endpoints)
                - Each message attribute should have name, type and value
    - Mobile Apps: Mobile Push with SNS
        - Instead of pushing directly to an endpoint we push to a Push Notification Service which in turn pushes to our subscriber endpoint (mobile device with our app)
            - Amazon Device Messaging (ADM)
            - Apple Push Notification Service (APNS)
            - Baidu Cloud Push
            - Google Cloud Messaging for Android
            - Microsoft Push Notification Service for Windows Phone
            - Windows Push Notification Services
        - SNS needs a device token in order to send notifications to mobile endpoints
        - Depending on mobile platform there are device tokens or registration IDs.
            1) Request credentials from mobile platforms (ADM, APNS, etc.)
                - Credentials will be returned from the mobile push notification platforms.
            2) Request a token from mobile platforms
                - Using the credentials from #1 we request a token from the different mobile push notification platforms for the mobile app and device.
                - The token will be used to represent this specific device
            3) Create a platform application object
                - Using the credentials + device token we create a Platform Application Object.
                - This is part of what we need to send direct push notifications to mobile platforms.
                - a PlatformApplicationArn is returned.
            4) Create a platform endpoint object
                - Using the platformApplicationArn we create a platform endpoint object.
                - This object uniquely identifies and provides push notification access to the device and notification platform!
                - an EndpointArn is returned.
            5) Publish a message to the mobile endpoint
                - Using the EndpointArn we publish a message to mobile endpoint.
- SQS
    - Concepts
        - A queue of messages.
        - Uses a polling method (SNS uses push)
        - Loosely coupled components result in high availability, reliability and scalability
        - Protects against losing data in case of application failure. Queue will eventually still get consumed.
        - Redundant infrastructure ==> Guarantees delivery of message AT LEAST ONCE - no promise of ORDER
        - Multiple writers/readers ==> Multiple components can send/receive messages simultaneously.
        - Queues can be configured ==> different settings depending on needs.
        - Access control on who is allowed to send and receive (IAM or SQS policies)
        - Delay queues ==> Control how much time goes by before a message is available (0s-15 minutes)
        - PCI compliant!! 
        - "Visibility timeout" (0s - 12 hours)
            - Used to block other components from processing a message
            - Can be extended for individual messages if necessary
            - Controlable through SQS API
            - Messages are not deleted by SQS once processed. Must be actively deleted by component.
        - Short polling vs Long polling
            - Short polling returns immediately even if queue is empty
            - Short polling only checks subset of servers making false empty responses possible (NB: redundant infrastructure)
            - Long polling doesn't return a response until there is a message in the queue
            - Long polling checks EVERY server to avoid false empty responses
            - Long polling should be used when possible because it can reduce cost and false empty responses
        - Message Lifecycle
            - Component 1 sends message A to queue ==> Message is redundantly distributed across SQS servers
            - Component 2 is ready so it polls for messages from SQS.
                - Message A is being processed, but remains in queue, invisible to any other readers for the duration of the "visibility timeout" setting
            - Component 2 deletes message A from the queue
                - During "visibility timeout" or the message is available to be processed again
        - Terms and limitations
            - Message size: 256kb
                - If need larger messages store the content of the message in S3 or DynamoDB and let SQS hold a pointer to the AWS S3 object.
            - Max 120.000 inflight messages
                - Inflight: Component has received or consumed a message but has not deleted it from the queue yet.
            - Message Retention Period (1 minute - 14 days)
                - Amount of time a message will live in a queue if it is not deleted.
                - Another way of deleting messages if the Component has not deleted them yet.
            - Receive message wait time (0-20, 1-20 for long polling)
                - If value > 0 ==> long polling will be enabled.
                - maximum amount of time that a long polling call will wait for a message to become available before returning empty.
            - Dead letter queues
                - Queue other queues can send messages to when those messages have failed to be processed.
                - Maximum Receives setting on DLQ (1-1000): number of times a message can be received before being sent to DLQ. Applies to individual messages.
    - API Developer Requirements
        - Change messages visibility timeout:
            - ChangeMessageVisibility: Adds the specified amount of time to the message's current time left.
                - Setting this on a message with 1 second out of 120 seconds left, with a value of 120s will give it a total of 239 seconds visibility timeout.
                - AWS gives error if Visibility Timeout exceeds 12 hours. Will apply what it can up to maximum 12hrs
        - Change queues visibility timeout:
            - SetQueueAttributes:
                - Attribute.Name = VisibilityTimeout
                - Sets the default queue visibility timeout
        - Enable long polling on a queue:
            - ReceiveMessageWaitTimeSeconds: Anything greater than 0 enables long polling
        - Send message to queue:
            - SendMessage: Sends a message to a queue. Can be used to set a message's delay, as well as message attributes, and the message body
        - Delete a message from the queue:
            - DeleteMessage
        - Get a queue's URL:
            - GetQueueURL: Instead of hardcoding a queue's URL, we can retrieve the URL with this API call.
- CloudFormation
    - Essentials
        - Allows you to create and provision resources in a reusable template fashion
        - Turns resources into stacks that work as a "unit"
        - Allows to source control infrastructure
        - JSON compatible
        - Allows for cloud-init scripts for EC2 resources
        - Rollback
            - If a stack fails to create resource, it will by default rollback
            - Can be disabled from the API
        - CLI commands
            - cfn- prefix has been deprecated, however may be found on exam questions
            - cfn-describe-stacks: Same as API call DescribeStacks. Describes stacks
            - cfn-list-stacks: As above, but with ability to filter through different stacks statuses
        - API calls
            - ListStackResources: List all resources that belong to a cloudformation stack
            - DescribeStacks: List description for specified stack, or all stacks if no stack defined.
            - ListStacks: Returns summary informatino for stacks whose status matches the specified StackStatusFilter. Summary info is kept for 90 days past deletion of a stack.
    - Template anatomy
        - AWSTemplateFormatVersion (optional)
            - Specifies which AWS template version you want to use
        - Description (optional)
            - Follows template version section
            - AWSTemplateFormatVersion REQUIRED if Description specified.
            - Descriptions help clearly differentiate between templates
        - Metadata (optional)
            - JSON objects that provide details about the template
        - Parameters (optional)
            - Values you can pass in right before template creation
            - Allows customization of template
            - Can have default values as well as allowed values
        - Mappings (optional)
            - Maps keys to values. (e.g. make different values for different regions)
        - Conditions (optional)
            - Can check values before deciding what to do
            - Can create different resources in same template depending on condition evaluation
            - Example: Different environments for dev, test and prod.
        - Resources
            - Where you create resources (S3, EC2, Lambda, etc.)
        - Outputs (optional)
            - Can output values you'd like to see from the console or from API calls
            - Example: Can return the S3 bucket name created by the template
    - Intrinsic Functions
        - Used to pass in values that are not available until run time
            - Example: Need ARN value of resource.. You need to create resource before ARN available. E.g. for SNS coupled on other services
        - Can only be used in Resource properties, Metadata attributes and Update Policy attributes.
        - Fn::GetAtt (GetAttribute)
            - Get Website URL for just created S3 bucket:
            "Resources": { "S3Bucket" : { ... } },
            "Outputs": { "WebsiteURL" : {
                "Value": { "Fn::GetAtt": [ "S3Bucket", "WebsiteURL" ] },
                "Description": "URL for website hosted on S3"
            }
        - Fn::FindInMap
            - E.g. get AMI ID for various regions and architecture
            "Mappings" {
                "RegionMap": {
                    "us-east-1": { "32": "ami-12346578", "64": "ami-87654321" },
                    "us-west-1": { "32": "ami-23456789", "64": "ami-98765432" }
                }
            }
            "Resources": {
                "myEC2Instance": {
                    "Type": "AWS::EC2::Instance",
                    "Properties": {
                        "ImageId": { "Fn::FindInMap": [ "RegionMap", { "Ref": "AWS::Region" }, "32"]},
                        "InstanceType": "m1.small"
                    }
                }
            }
        - Fn::Join (Concatenates elements, separated by specified delimiter)
        - Ref (returns a resource or value based on a logical name or parameter)
        - Fn::GetAZs (get availability zones for specified region)
        - Fn::Select (Returns a single object from a list of objects by index)
- Elastic Beanstalk
    - Overview
        - Used to deploy applications on AWS without worrying about infrastructure
        - Languages supported
            - Java, .NET, PHP, Node.js, Python, Ruby, Go
        - Webservers & Containers:
            - Apache, IIS, Java SE, Nginx, Passenger, Puma, Tomcat, Docket
        - Deployment platforms
            - Git, IDEs, Manual upload
        - When to use
            - Spend minimal time learning to setup infrastructure
            - Quick prototyping/testing
            - Increase developer productivity
            - Maintain flexibility and control over the resources used to power your application
        - When not to use
            - If you need complete control of resource configurations
            - Existing applications can be difficult to fit in the Elastic Beanstalk "model"
            - Installing dependencies is different than simply using "apt-get" and can complicate things if you have a lot of dependencies
        - Core components
            - Application
                - Collection of components like environment, version and configuration (think folder with files)
            - Application Version
                - Part of an application
                - Each version unique.
                - Multiple versions can be deployed
            - Environment
                - An application version that is deployed onto AWS resources
            - Environment Configuration
                - Settings and parameters that define the environment and resources
            - Configuration templates
                - Used to create repeatable environment configurations
- Simple Workflow Service
    - Overview
        - Similar to SQS.
            - Both are used to create distributed systems
            - Both allow each task/component to scale independently
            - SQS uses 'best-effort' messaging order and could have duplicates
            - SWF guarantees execution order and uses deciders for next instruction
            - SWF can have a human task as part of the workflow
            - SQS messages live up to 14 days
            - SWF workflows or task executions can last up to 1 year
            - SWF allows for synchronous and asynchronous distributed processing
        - Task coordination and state management service
        - Allows us to define step-by-step workflow.
            - Each step can be called component/task
            - Each task/component has a set of workers that executes the task instructions
        - Distributed service so all components are broken up to different pieces to allow scaling up on demand if a a task requires more resources.
        - Works with on-prem applications or applications in the cloud
        - A "decider" coordinates and decides which tasks to execute next.
            - Decider sends a task a set of instructions
            - When a worker is done executing a job it will return a result to the decider
            - Decider decides which task to run next based on this result.
        - Workflows can last up to 1 year
        - Guarantees order of execution!
        - Workflow CAN consist of human events (offline task, e.g. filing something in an office)
    - Domains
        - Used to help determine the scope of workflows
        - Multiple workflows can live inside of a domain
        - Workflows cannot interact with workflows in other domains
        - Domain is the "scope"
    - Workers
        - Activity worker -- process that performs an activity that is part of the workflow
        - Activity worker poll SWF for new tasks that they need to perform
        - Worker can consist of a server on EC2 or on-prem.
    - Tasks
        - Activity task
            - e.g. encode video or check inventory
        - Decision task
            - Tells the decider that the state of the workflow execution has changed
            - Allows the decider to detmine what the next activity is
            - Decision tasks happen whenever the state of the workflow changes (task completed)
    - Examples
        - E-Commerce
            - Customer orders (start)
            - Verify Order (Order verifiers)
            - Charge Credit Card (credit card processors)
            - Ship Order (human)
            - Record Completion (database recorders)
            - End
        - Transcoding videos
            - Pick video file (human or S3->SNS->)
            - Transcode (transcoder)
            - Select thumbnail (human)
